#include ".././type/types.h"
/*
contains the Local APIC ID, which represents the identifier of the local APIC.
*/
#define ID (0x0020 / 4)
/*
The Version register provides information about the version and capabilities of
the local APIC.
*/
#define VER (0x0030 / 4)
/*
The Task Priority register determines the priority level of the current task or
thread being executed. It is used to control the interrupt priority of the
processor. Higher priority tasks are allowed to interrupt lower priority tasks.
The TPR register is an 8-bit register, and each bit represents a different
priority level. The higher the value in the TPR register, the lower the priority
of the task.
*/
#define TPR (0x0080 / 4)
/*
The End Of Interrupt (EOI) register is used to signal the completion of an
interrupt handling routine. When an interrupt is serviced, the EOI register is
written with the interrupt vector number to indicate that the interrupt
processing is finished.
*/
#define EOI (0x00B0 / 4)
/*
SVR (0x00F0 / 4): The Spurious Interrupt Vector register contains the vector
number for the spurious interrupt handler.

When an interrupt occurs but it is not handled by any specific interrupt
handler, it is routed to the spurious vector. The spurious vector is typically
configured to point to a spurious interrupt handler routine that handles these
unhandled interrupts.
*/
#define SVR (0x00F0 / 4)
/*
the ENABLE constant is being used as a flag or configuration setting to enable a
specific feature.
*/
#define ENABLE 0x00000100
/*
The Error Status register holds information about any errors that occur during
the operation of the local APIC.
*/
#define ESR (0x0280 / 4)
/*
The Interrupt Command register (lower 32 bits) is used to send inter-processor
interrupts (IPIs) and other commands. It allows communication between multiple
processors in a system. The ICRLO register is used to specify the destination
processor(s) and the type of interrupt/command to be sent.

For example, in a multi-processor system, if one processor needs to communicate
with another processor, it can use the ICRLO register to send an inter-processor
interrupt (IPI) or other commands. By writing specific values to the ICRLO
register, the sending processor can target a specific destination processor or a
group of processors, and specify the type of interrupt or command to be
delivered. This mechanism enables inter-processor communication and coordination
in the system.
*/
#define ICRLO (0x0300 / 4)
/*
It is responsible for generating periodic timer interrupts on the local
processor. The value written to the TIMER register determines the frequency of
the timer interrupts. In clock ticks

In many operating systems, a periodic timer interrupt is used for various
purposes, such as scheduling tasks, updating system timers, or triggering
specific actions at regular intervals. The TIMER register is utilized to
configure and control the local timer interrupt. By writing a suitable value to
the TIMER register, the operating system sets the frequency of the timer
interrupts generated by the local processor. This allows the system to have
precise timing and perform periodic tasks according to the specified interval.
*/
#define TIMER (0x0320 / 4)
/*
The clock divider is a component in a system that divides the frequency of an
input clock signal to obtain a lower frequency output signal. It is often used
in digital systems to generate clocks with different frequencies for different
components or subsystems.

Example :
Let's say we have a system with an input clock signal of 100 MHz (100,000,000
Hz), and we want to generate a timer interrupt at a frequency of 1 kHz (1,000
Hz).

We can achieve this by configuring a timer with a clock divider. The clock
divider will divide the input clock frequency by a certain factor to obtain the
desired timer interrupt frequency.

In this case, to generate a 1 kHz timer interrupt, we can set the clock divider
to divide the input clock by a factor of 100,000. This means that for every
100,000 input clock cycles, the timer will generate a single timer interrupt.

By programming the timer's clock divider register with the value 0x0000000B
(X1), we indicate that the clock divider should divide the input clock by a
factor of 1, meaning no division is performed. Therefore, the timer interrupt
frequency will be the same as the input clock frequency, which is 100 MHz.

To generate a 1 kHz timer interrupt, we would actually need to set the clock
divider to a different value, such as 0x0001869F (assuming the timer hardware
supports this granularity), which corresponds to dividing the input clock by a
factor of 100,000.
*/
#define X1 0x0000000B
/*
This value is used to configure the timer mode for generating periodic timer
interrupts.

When the timer mode is set to PERIODIC, it means that the timer will generate
interrupts at a fixed interval repeatedly. The interval is determined by the
value written to the timer hardware register.

Periodic timer interrupts are commonly used in operating systems and other
software systems for various purposes, such as task scheduling, timekeeping, and
triggering periodic actions.
*/
#define PERIODIC 0x00020000
/*
The Timer Initial Count register specifies the initial count value for the local
APIC timer. The initial count value for the local APIC timer is typically
specified in clock ticks. A clock tick represents a discrete unit of time
determined by the system's clock frequency.

The specific interval between interrupts is determined by the initial count
value set in the TICR (Timer Initial Count) register.
*/
#define TICR (0x0380 / 4)
/*
The Timer Current Count register holds the current count value of the local
APIC timer. It provides information about the remaining time until the next
timer interrupt occurs.
*/
#define TCCR (0x0390 / 4)
/*
The Timer Divide Configuration register determines the clock divider for the
local APIC timer.
*/
#define TDCR (0x03E0 / 4)
/*
The Performance Counter LVT (Local Vector Table) register is used for
performance monitoring interrupts. It enables performance monitoring events
such as counting cache misses, instruction retirements, etc. The PCINT register
is used to configure the performance monitoring unit and specify the event to
be monitored.

In some systems, a performance monitoring unit is available to measure and
analyze the system's performance characteristics, such as cache utilization,
instruction execution, or other events of interest. The PCINT register is used
to configure the performance monitoring interrupts. By programming the PCINT
register, the operating system can specify the performance event to be monitored
and enable the generation of interrupts when the event occurs. This allows
performance monitoring tools or software to collect data and analyze the
system's performance based on the recorded events.
*/
#define PCINT (0x0340 / 4)
/*
The Local Vector Table 1 register is used for the local interrupt 0 (LINT0)
handling.

The LINT0 interrupt can be configured to generate the Non-Maskable Interrupt
(NMI) on the local processor. This type of interrupt is used for critical system
events that require immediate attention and cannot be masked or disabled. For
example, if a hardware failure or system error occurs, the NMI can be triggered
to ensure that the system's attention is immediately brought to the issue.

These are just a couple of examples, and the specific usage of LINT0 and LINT1
interrupts can vary depending on the system design and requirements.
*/
#define LINT0 (0x0350 / 4)
/*
LINT1 (0x0360 / 4): The Local Vector Table 2 register is used for the local
interrupt 1 (LINT1) handling.

The LINT1 interrupt is commonly used for thermal monitoring and control in the
system. It is typically connected to the thermal sensor on the processor or
other components to monitor their temperature. When the temperature exceeds a
certain threshold, the LINT1 interrupt can be generated to trigger a thermal
management routine. This routine might involve slowing down the processor,
activating cooling mechanisms, or taking other actions to mitigate the
temperature rise and prevent damage to the hardware.

These are just a couple of examples, and the specific usage of LINT0 and LINT1
interrupts can vary depending on the system design and requirements.
*/
#define LINT1 (0x0360 / 4)
/*
is used for error handling. It is used to handle error conditions related to the
local APIC, such as APIC bus errors or parity errors.
*/
#define ERROR (0x0370 / 4)
/*
The DELIVS (Delivery Status) bit is used to track the delivery status of an
Inter-Processor Interrupt (IPI) that was sent by writing to the ICR.

When the system wants to send an interrupt to another processor, it writes the
necessary information into the ICR and initiates the interrupt delivery by
setting the appropriate command bits.

After this, the DELIVS bit will be set to 1 to indicate that the interrupt is in
the process of being delivered. Once the interrupt has been accepted by the
target processor, the DELIVS bit will be cleared back to 0.
*/
#define DELIVS 0x00001000
/*
ICRHI allows us to target specific processors when sending interrupts. The exact
layout and usage of the ICR can vary depending on the specific architecture and
version of the LAPIC.

In a multiprocessor system, each processor has its own LAPIC, and they can send
interrupts to each other through the ICR. The ICR is a 64-bit register that is
split into two 32-bit registers: ICRLO (Interrupt Command Register Low) and
ICRHI (Interrupt Command Register High).

When a processor wants to send an inter-processor interrupt (IPI), it sets up
the interrupt in the ICR. The low 32 bits (ICRLO) are used to specify the type
of interrupt and other details. The high 32 bits (ICRHI) are used to specify the
destination, i.e., the ID of the processor that should receive the interrupt.
*/
#define ICRHI (0x0310 / 4)
/*
Flag used to specify that the interrupt/command is an Init Level De-Assert
(INIT) command. An INIT command is used to synchronize the arbitration IDs of
the processors in a multiprocessor system during system initialization.
*/
#define INIT 0x00000500
/*
Flag that determines the interrupt delivery mode. When LEVEL is set, it
indicates that the interrupt is level-triggered. Level-triggered interrupts
remain active as long as the interrupt condition persists, unlike edge-triggered
interrupts that are triggered by a specific transition.

A level-triggered interrupt is an interrupt that remains active as long as the
interrupt condition persists. It means that once the interrupt signal is
asserted (active), the interrupt is continuously triggered and considered active
until the signal is de-asserted (inactive).

In the case of a level-triggered interrupt, the interrupt handler will be
continuously invoked as long as the interrupt condition exists. This allows the
handler to perform the necessary actions for the interrupt without missing any
occurrences of the interrupt signal.

Level-triggered interrupts are commonly used for devices or events that require
continuous handling, such as a timer interrupt or a hardware signal that remains
active until a specific condition is met.
*/
#define LEVEL 0x00008000

/*
Flag that indicates whether the interrupt/command should be broadcasted to all
processors in the system, including the current processor itself. When BCAST is
set, the interrupt/command is sent to all processors.
*/
#define BCAST 0x00080000
#define BUSY 0x00001000
#define FIXED 0x00000000
#define STARTUP 0x00000600  // Startup IPI
/*
In the LAPIC (Local Advanced Programmable Interrupt Controller), which is
responsible for managing interrupts on each processor in a multiprocessor
system, the ASSERT flag is used to control the state of an interrupt signal.
When the ASSERT flag is set, it means that the interrupt signal should be
asserted or active, indicating the occurrence of an interrupt. Conversely, when
the ASSERT flag is cleared or not set, it means that the interrupt signal should
be deasserted or inactive.

To notify the processor about the occurrence of an interrupt, the interrupt
signal needs to be asserted or active. This means that the signal is set to a
logic level that indicates the presence of the interrupt. The specific logic
level depends on the hardware implementation and the signaling protocol used.

For example, in many systems, interrupts are signaled by asserting a specific
line, such as an interrupt request (IRQ) line. When the interrupt is active or
asserted, the IRQ line is set to a logic level (often low) that represents the
occurrence of the interrupt. The processor detects this active signal and
responds accordingly by initiating the interrupt handling process.

Once the interrupt is serviced and the interrupt handler routine completes its
execution, the interrupt signal is typically deasserted or made inactive. This
means that the signal is cleared or set to a logic level (often high) that
indicates the absence of the interrupt. The processor recognizes this change in
the interrupt signal and resumes its previous execution.
*/
#define ASSERT 0x00004000
#define MASKED 0x00010000  // Interrupt masked
#define DEASSERT 0x00000000

/*
Returns the local APIC ID for the currently running processor.

APIC stands for Advanced Programmable Interrupt Controller.
It is a hardware component that manages interrupts in a computer system.

The APIC is responsible for routing interrupts to the appropriate processor or
core, prioritizing interrupts, and handling interrupt requests from various
devices.

In modern computer systems, the APIC is typically integrated into the CPU, and
each core has its own local APIC, which communicates with a centralized I/O
APIC. This design allows for better scalability and performance in multi-core
systems.
*/
int lapicid(void);
extern volatile uint* lapic;
/*
Acknowledge interrupt.
*/
void lapiceoi(void);
/*
responsible for initializing the local APIC (Advanced Programmable Interrupt
Controller) in an x86-based system.

This function is a bit to much theorical to be "understand" with a simple read.
Check the lapic doc to fully understand.
*/
void lapicinit(void);
/*
responsible for starting an additional processor (AP) by sending the necessary
initialization signals and code.

    apicid: This is the ID of the target AP that we want to start. The APIC ID
is a unique identifier assigned to each processor in a system.

    addr: This is the address of the entry code that will be executed by the AP
when it starts running. The entry code is typically located in the memory and
contains the initialization and setup instructions for the AP.
*/
void lapicstartap(uchar, uint);
/*
Spin for a given number of microseconds. On real hardware would want to tune
this dynamically.
*/
void microdelay(int);